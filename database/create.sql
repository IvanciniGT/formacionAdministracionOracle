
-- 
-- Tabla: Tipos de Cursos
--

CREATE TABLE Tipos_Cursos (
 -- NOMBRE                      TIPO            SI ADMITE NULO
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO                      VARCHAR2(50)    NOT NULL,
    NOMBRE                      VARCHAR2(100)   NOT NULL,
    DESCRIPCION                 VARCHAR2(4000),

 -- CONSTRAINS
    CONSTRAINT PK_Tipos_Cursos PRIMARY      KEY (ID),
    CONSTRAINT UQ_Tipos_Cursos_Codigo       UNIQUE (CODIGO) -- Identificador público del tipo de curso
);

-- Presenciales, Online, Híbridos y pocos más
-- Collates? En esta tabla no tiene mucho sentido
-- Índices?  No, con el unique ya tenemos un índice implícito
-- Además es una tabla pequeña... muy pequeña. del PCTFREE no nos tenemos que preocupar mucho














-- 
-- Tabla: Cursos
--

-- Nombre: SQL Avanzado para Oracle <-- Búsqueda: "sql oracle" (Esto pide a gritos un índice invertido full text: ORA TEXT)
-- Listado en una APP. Quiero sacar un listado de cursos.
-- Qué campos meto en el listado? <-- UX
-- - Los identificativos públicos (código, nombre)
-- - Cualquier dato que ayude a decidir al usuario si debe entrar en detalle o no
CREATE TABLE Cursos (
 -- NOMBRE                      TIPO            SI ADMITE NULO
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO                      VARCHAR2(50)    NOT NULL,
    NOMBRE                      VARCHAR2(100)   NOT NULL COLLATE SPANISH, -- sin preocuparnos de mayúsculas/minúsculas ni acentos, ya que eso son cosas que se usan en comparaciones y en nuestro no las habrá. Las búsquedas van por Oracle Text
    DURACION                    NUMBER,
    TIPO                        NUMBER,
    PRECIO_PARA_EMPRESAS        NUMBER,
    PRECIO_PARA_PARTICULARES    NUMBER,
    TEMARIO                     VARCHAR2(4000),
    OBJETIVOS                   VARCHAR2(1000),
    REQUISITOS                  VARCHAR2(1000),
    ORIENTADO_A                 VARCHAR2(1000),

 -- CONSTRAINS
    -- Primary Key. Siempre tenemos uno
    CONSTRAINT PK_Cursos PRIMARY                KEY (ID),
    -- Unique: Es nuestro ID PUBLICO
    CONSTRAINT UQ_Cursos_Codigo                 UNIQUE (CODIGO),
                                                -- Este campo, por tener ser una clave única en automático tiene un índice asociado
                                                -- Búsquedas del tipo WHERE CODIGO = 'valor' serán muy rápidas
                                                -- Búsquedas del tipo WHERE CODIGO LIKE 'valor%' serán muy rápidas
    -- Foreign Key hacia Tipos_Cursos
    CONSTRAINT FK_Cursos_Tipo FOREIGN           KEY (TIPO) REFERENCES Tipos_Cursos(ID),
    -- Restricciones al valor de los campos
                                                -- AQUI PONEMOS UNA EXPRESION QUE DEVUELVA UN BOOLEANO
                                                -- Si devuelve TRUE, se acepta el valor
                                                -- Si devuelve FALSE, se rechaza el valor
    CONSTRAINT CHK_Cursos_Duracion              CHECK (DURACION IS NULL OR DURACION > 0),
    CONSTRAINT CHK_Cursos_Precio_Empresas       CHECK (PRECIO_PARA_EMPRESAS IS NULL OR PRECIO_PARA_EMPRESAS >= 0),
    CONSTRAINT CHK_Cursos_Precio_Particulares   CHECK (PRECIO_PARA_PARTICULARES IS NULL OR PRECIO_PARA_PARTICULARES >= 0),
    CONSTRAINT CHK_Cursos_Codigo_Mayusculas     CHECK (CODIGO = UPPER(CODIGO) AND REGEXP_LIKE(CODIGO, '^[A-Z0-9_-]+$'))
) PCTFREE 15; -- Valor por defecto

-- PCTFREE?
-- Cuánto ocupa un curso en la BBDD?

-- Los campos number son muy poquito... en este caso, casi despreciable
-- Quién marca el tamaño? TEMARIO. Es un campo que habitualmente estará relleno o no? SIEMPRE
--                        OBJETIVOS, REQUISITOS, ORIENTADO_A que van a estar rellenos.
-- Entre ellos pueden llegar a 4000 + 1000 + 1000 + 1000 = 7000 bytes
-- Posiblemente nunca se rellenen del todo... pero una media aproximada podría ser 4000-5000 bytes podría tener sentido
-- NOTA: Interesaría realmente hacer un estudio de uso real de esos campos para ver cuánto se usa realmente
-- Hago ese estudio... y sale que un curso de media ocupa unos 5000 bytes
-- No es el típico campo Observaciones... Notas... Comentarios.. Que la mayor parte de las veces estará vacío

-- Cual es el tamaño de bloque por defecto? 8KB = 8192 bytes
-- Si eso es así, cuántos cursos caben en un bloque? 1
-- Y de media, en cada bloque me quedara un espacio libre de 2500-2800 bytes.
-- Es decir, un desperdicio de espacio del 30-35% <- Aceptable? Posiblemente demasiado alto

-- Cuantos cursos tendremos?  10.000, 100.000, 1.000.000?
-- Estaremos en unos 1.000 cursos como mucho
-- Entonces: 1.000 cursos * 2.5KB = 2.5MB ... Sigue pareciendo mucho desperdicio? No tanto.

-- Cuando un curso se dé de alta... inicialmente es posible que no tenga ninguno de los campos 
-- Gordos rellenos. Es decir, ocupara unos pocos cientos de bytes. (100-200 bytes)
-- En este escenario, cúantos cursos caben en un bloque? 40-80 cursos
-- El problema estará cuando se vayan actualizando los cursos y se vayan rellenando esos campos gordos.
-- Que va a ser necesario hacer? Qué hará Oracle? 
-- Van a entrar las actualizaciones de 40 cursos en el bloque? NO... hemos dicho que en un bloque, una vez rellenos los campos
-- gordos, solo cabe 1 curso.... 40?
-- Oracle tendrá que:
-- 1. Mover el curso a otro bloque que tenga espacio suficiente (row-migration)
-- 2. Marcar el registro como fragmentado (tombstone) y completarlo en otro bloque (row-chaining)
-- Eso era bueno? NO... nada bueno para el rendimiento
-- PERO NADA !
-- Con qué frecuencia va a pasar eso en nuestro caso? BASICAMENTE EN TODOS LOS CURSOS!
-- ESTO SI ES UN PROBLEMON!
-- SOLUCION?
-- Vamos a hacer 2 cosas:
-- 1. Con respecto al tamaño de bloque. Ni de coña lo voy a dejar en 8KB. Lo pongo en 32KB.
--    El problema es que el tamaño de bloque no se puede establecer a nivel de tabla.
--    Se asocia a un TABLESPACE. Vamos a crear un tablespace específico para este tipo de tablas.
--    En nuestro caso y por ahora solo tendremos esta tabla en ese tablespace.

CREATE TABLESPACE ts_cursos
    DATAFILE 'ts_cursos01.dbf' SIZE 100M
    BLOCKSIZE 32768
    EXTENT MANAGEMENT LOCAL
    SEGMENT SPACE MANAGEMENT AUTO
    ; -- 32KB

-- Mover la tabla Cursos a ese tablespace
ALTER TABLE Cursos MOVE TABLESPACE ts_cursos;
--Podría haber creado la tabla directamente en ese tablespace al crearla:
-- CREATE TABLE Cursos (..) TABLESPACE ts_cursos;
--    Al hacer esto consigo:
--    1. Que en un bloque de 32KB entren varios cursos 4, 5, 6
--    2. Ya no juego con 1 único curso por bloque... ahora, tendré cursos un poco más grandes
--       que otros... y se acomodarán mejor en los bloques, reduciendo la cantidad de espacio libre que desperdicio

-- 2. PCTFREE. Vamos a configurar un valor enorme. De forma que pueda garantizar que cuando un curso ha entrado
--             En un bloque, haya espacio suficiente para que se pueda terminar de rellenar sin que tenga que moverse de bloque
--  Los datos de inicio de un curso estarán en torno a 200 bytes x 6 cursos = 1200 bytes
--  La cabecera del bloque ocupa unos 84 bytes + 2 bytes por fila = 84 + 12 = 96 bytes
--  En total = 1296 bytes. Que representa un 4% de un bloque de 32KB
-- No quiero ni un curso que se pueda meter más en el bloque fuera de 6 cursos
-- PCTFREE = 96%
-- Con esto me aseguro de que en un bloque de 32KB, cuando entren 6 cursos, quedará espacio suficiente
-- Y estoy evitando totalmente el row-migration y el row-chaining
-- O al menos minimizándolo muchísimo
-- Hay que tener más cosas en cuenta... No solo lo que ocupan los cursos de media, también la desviación típica
-- Más o menos son todos iguales? o hay mucha diferencia de tamaño entre unos y otros?
-- Posiblemente, un valor tan extremo no sea aconsejable. Pero desde luego subirlo un montón si.
-- Si no anulo el efecto de row-migration y row-chaining, al menos lo minimizo mucho.

-- El análisis no ha estado mal. 
-- Pero hay algo que ha fallado.
-- Hemos dado por supuesto que todos los cursos se meten vacios a la vez.
-- Tengo un curso que se mete inicialmente vacio. -> 200 bytes
-- Se rellena al poco. -> 5000 bytes
-- Tengo ya lleno el 5300 / 32768 = 16% del bloque
-- Si me pasa esto con 2 cursos, ya voy por el 30% del bloque ocupado
-- Eso implica que ya no queda más del 70% libre
-- Si he definido PCTFREE 80%, ya no puedo meter más cursos en ese bloque
-- Resultado despercidio por un tubo.
-- Parece que no ha sido tan buena solución.
-- Hay que plantearlo de otra forma:
-- Al dar de alta un curso, debe quedar espacio para poder rellenarlo completamente.
-- 1 curso -> 5000 bytes, que representa un 15% del bloque

-- Eso es lo que puedo llegar a configurar con PCTFREE
-- Y eso en cualquier caso, aunque minimice un poquito el row-migration y el row-chaining
-- Solo lo hace un poquito.

-- Conclusión: ESTA TABLA VA A NECESITAR BASTANTE MANTENIMIENTO DE LA BASE DE DATOS
-- Por suerte, es una tabla pequeña, con pocos datos
-- Y reescribirla de tanto en tanto no es un problema tan grande

-- Cada X tiempo (horas, días, semanas) habrá que hacer un REBUILD de la tabla Cursos
-- Y será una tarea que voy a programar en el mantenimiento de la BBDD
-- Si no ha habido muchas inserciones y actualizaciones, no será necesario hacerlo tan a menudo
-- Iré mirando cada cuanto tiempo es necesario hacerlo

-- Como decía aquí el problema no es tanto el espacio desperdiciado
-- Sino evitar el row-migration y el row-chaining

-- Si la tabla fuera más grande si habría más problema... y necesitaríamos buscar otras estrategias 
-- para facilitar el mantenimiento de la tabla. Muy probablemente particionándola.
-- habría particiones que iríamos cerrando y que una vez cerradas ya no requerirían mantenimiento
-- Los campos de tipo fecha podrían ayudar a particionar la tabla
-- Campos de tipo estado (activo, inactivo, cerrado, ...) podrían ayudar a particionar la tabla
-- O via un trigger, al completar los datos de un curso, moverlos a otra tabla de cursos completados

-- Notas respecto al campo CODIGO:
-- - Será muy recomendable implementar un AUTOCOMPLETAR en los formularios de búsqueda: ORA-     ora-      Ora-
-- - Podría ser que el usuario escriba minúsculas o mayúsculas de forma indistinta al buscar <- Quiero dar esa opción?
-- - Lo que nos estamos preguntando es: Quiero que el valor de ese campo sea case-sensitive o case-insensitive?
-- - Y en un campo como este, lo guay es que sea case-insensitive
-- - Esa funcionalidad la podríamos implementar en una query : WHERE UPPER(CODIGO) = UPPER('valor_del_usuario')
--                                                             WHERE UPPER(CODIGO) LIKE UPPER('valor_del_usuario') || '%'
--                                                             WHERE UPPER(CODIGO) LIKE '%' || UPPER('valor_del_usuario') || '%'
-- Pregunta?  Me funciona el índice que he creado en esos casos?
-- Respuesta: NO, ya que lo que tengo indexado es el valor del CODIGO... y en la query se usa el UPPER(CODIGO).
--            Y ese valor no está indexado!
-- Esto implica que hay que transformar bajo demanda, en cada query, todos los valores del campo CODIGO a mayúsculas
-- para poder comparar con el valor que ha dado el usuario. EL INDICE SE VUELVE INUTIL!
-- Opciones:
-- 1. Transformar en automático el valor del campo CODIGO a mayúsculas en el momento de hacer el INSERT o el UPDATE
--    Eso lo permite SQL? NO
--    Con un trigger y PL/SQL SÍ
-- 2. Forzar que el campo solo pueda recibir valores en mayúsculas. Limitación al rango de valores aceptables
--    Eso lo permite SQL? SÍ, con un CONSTRAINT CHECK
-- 3. Generar un índice adicional basado en la función UPPER(CODIGO). Índice funcional
--    Eso lo permite SQL? SÍ
--    CREATE INDEX IX_Cursos_Codigo_Upper ON Cursos(UPPER(CODIGO));
--    En este caso, tendríamos 2 índices. Más espacio y más tiempo en los INSERTs/UPDATEs.
--    Y Además, lo que me gustaría es de alguna forma NORMALIZAR el valor del campo CODIGO a mayúsculas.
--    Esto no exige que el campo se almacene en mayúsculas, pero sí que el valor indexado lo esté.
--    En otros escenarios, esto podría ser una solución interesante. En este NO.

-- Entre opción 1 y opción 2, nos quedamos con las 2.
-- La opción 2, es la que asegura que el valor del campo CODIGO siempre estará en mayúsculas.
-- La opción 1, es la que nos permite dar al usuario la flexibilidad de escribir minúsculas o mayúsculas al dar de alta el campo.

-- Implementando eso (o incluso si implementamos la opción 3), las búsquedas que usarán índice serían:
-- WHERE CODIGO = UPPER('VALOR_EN_MAYUSCULAS')
-- WHERE CODIGO LIKE UPPER('VALOR_EN_MAYUSCULAS') || '%'
-- ESTA NO FUNCIONA : WHERE CODIGO LIKE '%' || UPPER('VALOR_EN_MAYUSCULAS') 
--                    La búsqueda sin funcionaría, pero no usaría índice
-- El % al principio en los LIKES impide usar índice. Estas queries deberían estar proscritas en un entorno con grandes volúmenes de datos.
-- A no ser que tenga 200 datos en la tabla, claro.
-- Si quiero búsquedas de ese estilo, o búsquedas que no discrimen por acentos, o que automáticamente ignoren mayúsculas/minúsculas, la solución es otra:
-- - Índices invertidos full text: Oracle Text (eso viene con la propia licencia de Oracle Database), aunque he de activarlo explícitamente y configurarlo


-- Trigger para asegurar que el campo CODIGO siempre se almacena en mayúsculas
CREATE OR REPLACE TRIGGER TRG_Cursos_Codigo_Mayusculas
BEFORE INSERT OR UPDATE ON Cursos
FOR EACH ROW
BEGIN
    -- Solo transformamos el valor si no es NULL
    -- De esta forma evitamos que el trigger falle al intentar transformar un NULL
    -- Si es nulo, lo dejamos como está, es decir NULL
    -- Y ya la restricción NOT NULL definida en la tabla se encargará de rechazarlo si es necesario dando un mensaje adecuado al usuario

    -- En el caso de un UPDATE, si el valor no cambia, el valor :NEW.CODIGO se queda como está, no lo tocamos... y sigue funcionando bien.
    IF :NEW.CODIGO IS NOT NULL THEN 
        :NEW.CODIGO := UPPER(:NEW.CODIGO);
    END IF;
END;
/
-- Nota: El trigger se define con una barra (/) al final para indicar a SQL*Plus que ejecute el bloque PL/SQL.

-- TODO: Crear un índice invertido full text con Oracle Text para el campo NOMBRE












-- Tabla Profesores:
-- ID, Nombre, Apellidos, DNI


CREATE TABLE Profesores (
    ID                          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    NOMBRE                      VARCHAR2(50)    NOT NULL COLLATE SPANISH,
    APELLIDOS                   VARCHAR2(150)   NOT NULL COLLATE SPANISH,
    DNI                         VARCHAR2(9)     NOT NULL,

 -- CONSTRAINS
    -- Primary Key. Siempre tenemos uno
    CONSTRAINT PK_Profesores PRIMARY             KEY (ID),
    -- Unique: Es nuestro ID PUBLICO
    CONSTRAINT UQ_Profesores_DNI                 UNIQUE (DNI)
    -- Restricciones al DNI aplicadas mediante un TRIGGER
) PCTFREE 3;

-- Imaginemos una pantalla para buscar profesores en una app que use esta tabla
--
-- Buscar Profesor:
--     DNI:       [__________]
--     Nombre:    [__________]    Esto es como hacíamos estas pantallas hace 30 años
--     Apellidos: [__________]    Básicamente es llevar la BBDD al formulario
--                    [Buscar]      Ergonómicamente y UX nula!

-- Mucho mejor sería algo como:
-- Buscar Profesor: [                     ] [Buscar]  <- datoFormulario
-- Fácil, sencillo, rápido, sin lugar a dudas.

-- Imaginemos que tenemos muchos profesores (no es el caso)
-- E imaginemos que solemos usar mucho esa pantalla.

-- Qué haríamos a nivel de BBDD?
-- Creo índice por nombre, apellidos y dni? 3 índices?


SELECT * FROM PROFESORES WHERE NOMBRE    LIKE '%' || :datoFormulario || '%'
                            OR APELLIDOS LIKE '%' || :datoFormulario || '%'
                            OR DNI       LIKE '%' || :datoFormulario || '%';

SELECT * FROM PROFESORES WHERE NOMBRE || ' ' || APELLIDOS || ' ' || DNI LIKE '%' || :datoFormulario || '%';

-- Claro... mayúsculas/minúsculas y acentos?

SELECT * FROM PROFESORES WHERE UPPER(NOMBRE) || ' ' || UPPER(APELLIDOS) || ' ' || UPPER(DNI) LIKE '%' || UPPER(:datoFormulario) || '%';


-- Vamos jodidos...
-- Y espera...  se usan ahí los índices que hemos creado? En niguna de las 3 opciones!

-- SOLUCION A ESTE ENIGMA.... CHACHACACHAAN!!!

ALTER TABLE Profesores ADD (
    BUSQUEDA VARCHAR2(209) GENERATED ALWAYS AS (
        UPPER(NOMBRE) || ' ' || UPPER(APELLIDOS) || ' ' || UPPER(DNI)
    ) VIRTUAL -- Es decir, no se almacena físicamente en disco, se calcula bajo demanda
);

-- Ahora creo un índice de texto completo (full text) sobre esa columna BUSQUEDA
-- Usando Oracle Text
CREATE INDEX IX_Profesores_Busqueda ON Profesores(BUSQUEDA)
    INDEXTYPE IS CTXSYS.CONTEXT; -- <-- Esta es la sintaxis para crear un índice de texto completo con Oracle Text

-- Las queries ahora serían:
SELECT ID, NOMBRE, APELLIDOS, DNI FROM PROFESORES WHERE CONTAINS(BUSQUEDA, :datoFormulario) > 0;

-- Esto funcionaría a medias.
-- FILA 17:   Juan          Pérez       12345678A
-- Formulario: "Juan" --> Coincide
-- Formulario: "Pérez" --> Coincide
-- Formulario: "perez" --> Coincide
-- Formulario: "12345678A" --> Coincide
-- Formulario: "12345678a" --> Coincide
-- Formulario: "1234" ---> UPS !
-- El motor de Oracle text, a priori nos busca palabras completas...
-- A priori. Puedo pedirle que descomponga las palabras en subcomponentes (tokens) más pequeños:
-- Es decir, que trabaje con "n-grams"
--    NOTA: Para los que usan postgres, esto es similar a usar la extensión pg_trgm
--          En postgres tenemos el concepto de los trigrams (3-grams)
-- En oracle lo defino al crear el índice:
DROP INDEX IX_Profesores_Busqueda;
CREATE INDEX IX_Profesores_Busqueda ON Profesores(BUSQUEDA)
    INDEXTYPE IS CTXSYS.CONTEXT
    PARAMETERS ('NGRAMS 3'); -- Aquí le digo que use n-grams de tamaño 3
    -- Hay muchas opciones de configuración en Oracle Text. Esto es solo un ejemplo sencillo
    -- A nivel del índice, el testo "Juan Pérez 12345678A" se descompone en los siguientes n-grams:
    -- "Jua", "uan", "an ", "n P", " Pe", "Pér", "ére", "rez", "ez ", "z 1", " 12", "123", "234", "345", "456", "567", "678", "78A"
    -- Y cada uno de esos n-grams se indexa por separado
-- Ahora las búsquedas serían:
SELECT ID, NOMBRE, APELLIDOS, DNI FROM PROFESORES WHERE CONTAINS(BUSQUEDA, :datoFormulario) > 0;

-- Meteremos un trigger a esa tabla para?
-- - Validar que lo que llega es correcto (formato + letra correcta)
-- - Normalizarlo (quitar puntos y guiones, poner letra en mayúsculas)

CREATE OR REPLACE TRIGGER TRG_Profesores_DNI_Validar_Normalizar
BEFORE INSERT OR UPDATE ON Profesores
FOR EACH ROW
DECLARE
    dni_valido      BOOLEAN;
    dni_numero      NUMBER(8);
    dni_letra       CHAR(1);
BEGIN
    -- Si el DNI Es null, no hacemos nada, y que el propio NOT NULL de la tabla se encargue de rechazarlo
    IF :NEW.DNI IS NULL THEN
        RETURN;
    END IF;
    -- Validar el formato del DNI
    dni_utils.validar_dni(:NEW.DNI, dni_valido, dni_numero, dni_letra);
    IF NOT dni_valido THEN
        RAISE_APPLICATION_ERROR(-20001, 'DNI inválido: ' || :NEW.DNI); -- Este mensaje le saldrá al usuario si el DNI no es válido
    ELSE
        -- Si es válido, normalizar el valor del DNI
        :NEW.DNI := TO_CHAR(dni_numero) || dni_letra; -- Número sin ceros a la izquierda + letra en mayúsculas, sin puntos ni separadores
    END IF;
END;
/

-- Esto estaría acabado! al menos lo referente a la tabla profesores.


-- Relación nxm entre profesores y cursos

CREATE TABLE Profesores_Cursos (
    PROFESOR_ID    NUMBER      NOT NULL,
    CURSO_ID       NUMBER      NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Profesores_Cursos PRIMARY KEY (PROFESOR_ID, CURSO_ID),
    CONSTRAINT FK_Profesores_Cursos_Profesor FOREIGN KEY (PROFESOR_ID) REFERENCES Profesores(ID),
    CONSTRAINT FK_Profesores_Cursos_Curso FOREIGN KEY (CURSO_ID) REFERENCES Cursos(ID)
) PCTFREE 0;

-- Índices... tenemos índice ahí?
-- La primary key SI genera un índice implícito sobre (PROFESOR_ID, CURSO_ID)
-- Nos vale? Me temo que no!
-- Ese índice se usará solo si buscan por PROFESOR_ID
-- Y me temo que búsqueda mucho mucho mucho más habitual es buscar por CURSO_ID
-- Me interesa el qué? Darle la vuelta a esa clave primaria:
DROP TABLE Profesores_Cursos;
CREATE TABLE Profesores_Cursos (
    PROFESOR_ID    NUMBER      NOT NULL,
    CURSO_ID       NUMBER      NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Profesores_Cursos PRIMARY KEY (CURSO_ID, PROFESOR_ID),
    CONSTRAINT FK_Profesores_Cursos_Profesor FOREIGN KEY (PROFESOR_ID) REFERENCES Profesores(ID),
    CONSTRAINT FK_Profesores_Cursos_Curso FOREIGN KEY (CURSO_ID) REFERENCES Cursos(ID)
) PCTFREE 0;

-- Tabla Empresas

-- ID, Nombre, CIF, Dirección, Teléfono, Email
-- Una empresa debe tener al menos un número de teléfono... aunque puede tener varios

CREATE TABLE Empresas (
    ID              NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    NOMBRE          VARCHAR2(100)   NOT NULL COLLATE SPANISH,
    CIF             VARCHAR2(20)    NOT NULL, 
    DIRECCION       VARCHAR2(2000),
    EMAIL           VARCHAR2(100), 

 -- CONSTRAINS
    CONSTRAINT PK_Empresas PRIMARY  KEY (ID),
    CONSTRAINT UQ_Empresas_CIF      UNIQUE (CIF)
);

-- Si aplica, crear índices sobre CIF...y sobre nombre...
-- O un índice invertido full text con Oracle Text sobre NOMBRE concatenado con CIF
-- Por separado en base a los formularios que se vayan a usar en la aplicación cliente
-- Todo eso ya bajo demanda... y en cualquier caso exactamente igual que hemos hecho con Profesores

-- TODO: Nos falta 3 regex:
-- - Validar CIF (LETRAS Y NÚMEROS)
-- - Validar Email (Este es facil... en internet encontraréis muchos ejemplos)
-- - Validar Teléfono: (números, -, espacio, paréntesis y el +)
--   - MINIMO: +(192) 922 99 23 93
--   - GUAY: Hacer una validación un poco más exhaustiva y normalizar el teléfono, igual que hemos hecho con el DNI

-- Os lo dejo de regalo!
-- Mañana doy la solución
-- Al menos un mínimo!


CREATE TABLE Empresas_Telefonos (
    EMPRESA_ID     NUMBER       NOT NULL,
    TELEFONO       VARCHAR2(20) NOT NULL, 

 -- CONSTRAINS
    CONSTRAINT PK_Empresas_Telefonos PRIMARY KEY (EMPRESA_ID, TELEFONO),
    CONSTRAINT FK_Empresas_Telefonos_Empresa FOREIGN KEY (EMPRESA_ID) REFERENCES Empresas(ID) ON DELETE CASCADE
    -- ON DELETE CASCADE: Si se borra una empresa, se borran todos sus teléfonos asociados automáticamente
    -- Como se aplican los delete on cascade? Cuál es el orden de ejecución?
    -- 1. Se borra la empresa
    -- 2. Y después se borran todos los teléfonos asociados a esa empresa
    -- O:
    -- 1. Se borran todos los teléfonos asociados a esa empresa
    -- 2. Y después se borra la empresa
    -- La respuesta es la opción 2
    -- Y tenemos un problemón.
) PCTFREE 0;
-- Collates: NO Solo hay un campo de texto, que guarda un NUMERO de teléfono. 
--            No hay mayusculas/minúsculas ni acentos que tratar
-- Índices:   Tenemos? SI... el de la primary key
--            Y tiene sentido el orden? Todo el del mundo.
-- PCTFREE?
-- - 0 como a la de arriba? Me temo que si.
--   Los telefonos van a cambiar poco... pero pueden cambiar!
--   No obstante, aunque cambien, can a crecer en tamaño? NO

-- Como resolvemos la restricción de que una empresa debe tener al menos un teléfono?
-- No hay nada en SQL puro que lo permita.

-- Esto es territorio de PL/SQL.
-- Vamos a hacer que no se pueda insertar nada directamente en la tabla Empresas.

REVOKE INSERT ON Empresas FROM PUBLIC; -- Aqui el usuario para el que revocamos el permiso es PUBLIC, es decir, todos los usuarios

-- En su lugar, vamos a ofrecer como alternativa un procedimiento almacenado que haga el INSERT en Empresas y en Empresas_Telefonos

-- Opción 1: Exigir un teléfono en el procedimiento de creación
CREATE OR REPLACE PROCEDURE crear_empresa_con_telefono (
    p_nombre        IN VARCHAR2,
    p_cif           IN VARCHAR2,
    p_direccion     IN VARCHAR2,
    p_email         IN VARCHAR2,
    p_telefono      IN VARCHAR2
) IS
    -- variables locales
    nueva_empresa_id   NUMBER;
BEGIN

    -- Para poder hacer un rollback en caso de error al introducir el teléfono
    -- Vamos a hacer un SAVEPOINT
    SAVEPOINT antes_de_crear_empresa; -- Esto es un punto al que puedo volver si hay un error

    INSERT INTO Empresas (NOMBRE, CIF, DIRECCION, EMAIL)
    VALUES (p_nombre, p_cif, p_direccion, p_email)
    RETURNING ID INTO nueva_empresa_id;

    INSERT INTO Empresas_Telefonos (EMPRESA_ID, TELEFONO)
    VALUES (nueva_empresa_id, p_telefono);
-- Ahora puedo indicar el tratamiento que quiero implementar en caso de error
EXCEPTION
    WHEN OTHERS THEN -- Aqui podría poner el tipo de error específico que quiero capturar
                     -- Pero en este caso, me da igual el tipo de error
                     -- Cualquier error que se produzca en los inserts lo capturo aquí
        -- Si hay cualquier error, volvemos al savepoint
        ROLLBACK TO antes_de_crear_empresa;
        -- Y re-lanzamos el error para que el usuario se entere
        RAISE; -- que al usuario le llegue exactamente el mismo error que se ha producido
END;

-- Esto no solo nos mete la restricción que queremos implementar.
-- Tiene otra ventaja: Esto va más rápido que hacer 2 inserts desde la aplicación cliente.
-- Si hago 2 inserts, por qué va más lento?
-- - Solo tengo que ir a la BBDD una sola vez. Me quito latencia de las comunicaciones.
-- - Cuando lanzo una query a la BBDD que es lo primero que hace la BBDD?
--   Parsear la query: Analizarla sintácticamente, ver si es correcta
--   Validar los datos que se usan en la query (columnas) (existen, los tipos de datos coinciden, ???)
--   Generar un plan de ejecución
-- Al meterlo en un procedimiento almacenado, el código se compila, y se preparan planes de ejecución que se cachean.

-- Esto va guay. Ya una persona no puede bajo ningún escenario dar de alta una empresa sin teléfono.
-- Pero... podría una persona, una vez creada la empresa, borrar todos los teléfonos asociados a esa empresa?
-- Sí, podría. Y ESO ES UN PROBLEMA.

-- Podríamos hacer un procedimiento almacenado para borrar teléfonos de una empresa
-- Y hacer un revoke delete on Empresas_Telefonos from public   
-- Es matar moscas a cañonazos!

-- Otra opción es meter un trigger en la tabla Empresas_Telefonos
-- Que verifique, en cada delete, que la empresa sigue teniendo al menos un teléfono
-- Si no tiene ninguno, que lance un error y no deje hacer el delete

CREATE OR REPLACE TRIGGER TRG_Empresas_Telefonos_Al_Menos_Uno
BEFORE DELETE ON Empresas_Telefonos
FOR EACH ROW
DECLARE
    numero_telefonos   NUMBER;
BEGIN
    -- Contar cuántos teléfonos tiene la empresa a la que pertenece el teléfono que se va a borrar
    SELECT COUNT(*) INTO numero_telefonos
    FROM Empresas_Telefonos
    WHERE EMPRESA_ID = :OLD.EMPRESA_ID; -- :OLD porque estamos en un DELETE

    -- Si solo tiene uno teléfono, no dejamos borrar ese teléfono
    IF numero_telefonos <= 1 THEN -- Necesitamos evitar que este IF se ejecute 
                                  -- Si estamos borrando la empresa
                                  -- Necesitamos de alguna forma saber si se está borrando la empresa
                                  -- Ese es el único motivo por el que estaría bien borrar el último teléfono
                                  -- Necesito algun flag que me indique si se está borrando la empresa
                                  -- Como podemos implementar ese flag?
                                  -- Podríamos usar una variable de paquete
        RAISE_APPLICATION_ERROR(-20002, 'Toda empresa debe tener al menos un teléfono.');
    END IF;
END;
/
-- Qué es un Paquete en PL/SQL?
-- Un paquete es un contenedor lógico de código PL/SQL
-- Un paquete tiene 2 partes:
-- - Especificación del paquete: Declaraciones públicas (visibles desde fuera del paquete)
-- - Cuerpo del paquete: Implementación del código (código privado, no visible desde fuera del paquete, y código público, visible desde fuera del paquete)
-- En la especificación del paquete podemos declarar variables, constantes, tipos de datos, cursores, procedimientos y funciones
-- En el cuerpo del paquete implementamos los procedimientos y funciones declarados en la especificación
-- Por ahora, solo usaremos paquetes para declarar variables globales (visibles desde cualquier trigger o procedimiento almacenado)

CREATE OR REPLACE PACKAGE pkg_empresas IS
    borrando_empresa   BOOLEAN := FALSE; -- Variable para indicar si se está borrando una empresa
END pkg_empresas;

-- Ahora modificamos el trigger de borrado de teléfonos para que use esa variable

CREATE OR REPLACE TRIGGER TRG_Empresas_Telefonos_Al_Menos_Uno
BEFORE DELETE ON Empresas_Telefonos
FOR EACH ROW
DECLARE
    numero_telefonos   NUMBER;
BEGIN
    IF pkg_empresas.borrando_empresa THEN
        RETURN; -- Si se está borrando la empresa, no hacemos nada
    END IF;

    -- Contar cuántos teléfonos tiene la empresa a la que pertenece el teléfono que se va a borrar
    SELECT COUNT(*) INTO numero_telefonos
    FROM Empresas_Telefonos
    WHERE EMPRESA_ID = :OLD.EMPRESA_ID; -- :OLD porque estamos en un DELETE

    -- Si solo tiene uno teléfono, no dejamos borrar ese teléfono
    IF numero_telefonos <= 1 THEN -- Necesitamos evitar que este IF se ejecute 
                                  -- Si estamos borrando la empresa
                                  -- Necesitamos de alguna forma saber si se está borrando la empresa
                                  -- Ese es el único motivo por el que estaría bien borrar el último teléfono
                                  -- Necesito algun flag que me indique si se está borrando la empresa
                                  -- Como podemos implementar ese flag?
                                  -- Podríamos usar una variable de paquete
        RAISE_APPLICATION_ERROR(-20002, 'Toda empresa debe tener al menos un teléfono.');
    END IF;
END;
/
-- Esa variable ahora puedo establecerla en un trigger de borrado de la tabla Empresas

-- CREATE OR REPLACE TRIGGER TRG_Empresas_Borrado
-- BEFORE DELETE ON Empresas
-- FOR EACH ROW
-- BEGIN
    -- Indicar que se está borrando una empresa
    -- pkg_empresas.borrando_empresa := TRUE;
-- END;
-- /
-- Y ahora, para que todo vuelva a la normalidad, necesitamos un trigger AFTER DELETE   
-- CREATE OR REPLACE TRIGGER TRG_Empresas_Borrado_After
-- AFTER DELETE ON Empresas
-- FOR EACH ROW
-- BEGIN
    -- Indicar que ya no se está borrando una empresa
   --  pkg_empresas.borrando_empresa := FALSE;
-- END;
-- /

-- En lugar de crear 2 triggers en la tabla Empresas, uno BEFORE DELETE y otro AFTER DELETE
-- Podemos crear un solo trigger de tipo COMPOUND
CREATE OR REPLACE TRIGGER TRG_Empresas_Borrado
FOR DELETE ON Empresas
COMPOUND TRIGGER
    BEFORE STATEMENT IS
    BEGIN
        -- Indicar que se está borrando una empresa
        pkg_empresas.borrando_empresa := TRUE;
    END BEFORE STATEMENT;
    AFTER STATEMENT IS
    BEGIN
        -- Indicar que ya no se está borrando una empresa
        pkg_empresas.borrando_empresa := FALSE;
    END AFTER STATEMENT;
END TRG_Empresas_Borrado;
/

-- Opción 2: Permitir varios teléfonos usando un tipo colección

-- Para esta segunda opción, lo primero que necesito es definir un TIPO de datos, que me permita recibir 
-- muchos teléfonos en un solo parámetro
CREATE OR REPLACE TYPE tipo_telefonos AS TABLE OF VARCHAR2(20);

-- Y ahora podría crear un procedimiento almacenado que reciba ese tipo de datos como parámetro
CREATE OR REPLACE PROCEDURE crear_empresa_con_varios_telefonos (
    p_nombre        IN VARCHAR2,
    p_cif           IN VARCHAR2,
    p_direccion     IN VARCHAR2,
    p_email         IN VARCHAR2,
    p_telefonos     IN tipo_telefonos
) IS
    -- variables locales
    nueva_empresa_id   NUMBER;
BEGIN

    -- Verificar que realmente dentro de esa lista de teléfonos hay al menos un teléfono
    IF p_telefonos IS NULL OR p_telefonos.COUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'Debe proporcionar al menos un teléfono.');
    END IF;

    -- Para poder hacer un rollback en caso de error al introducir el teléfono
    -- Vamos a hacer un SAVEPOINT
    SAVEPOINT antes_de_crear_empresa; -- Esto es un punto al que puedo volver si hay un error

    INSERT INTO Empresas (NOMBRE, CIF, DIRECCION, EMAIL)
    VALUES (p_nombre, p_cif, p_direccion, p_email)
    RETURNING ID INTO nueva_empresa_id;

    -- Para cada telefono (ahora sé que al menos hay uno) hago el insert. BUCLE!
    FOR i IN 1 .. p_telefonos.COUNT LOOP
        INSERT INTO Empresas_Telefonos (EMPRESA_ID, TELEFONO)
        VALUES (nueva_empresa_id, p_telefonos(i));
    END LOOP;
-- Ahora puedo indicar el tratamiento que quiero implementar en caso de error
EXCEPTION
    WHEN OTHERS THEN -- Aqui podría poner el tipo de error específico que quiero capturar
                     -- Pero en este caso, me da igual el tipo de error
                     -- Cualquier error que se produzca en los inserts lo capturo aquí
        -- Si hay cualquier error, volvemos al savepoint
        ROLLBACK TO antes_de_crear_empresa;
        -- Y re-lanzamos el error para que el usuario se entere
        RAISE; -- que al usuario le llegue exactamente el mismo error que se ha producido
END;

-- Tabla Alumnos (nxm con empresas)
-- Tabla Convocatorias (Curso, Fecha Inicio, Fecha Fin, Estado)



-- AQUI ESTAMOS... y mañana seguimos!


CREATE TABLE Estados_Convocatoria (
    ID          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO      VARCHAR2(20)    NOT NULL,
    NOMBRE      VARCHAR2(100)   NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Estados_Convocatoria PRIMARY KEY (ID),
    CONSTRAINT UQ_Estados_Convocatoria_Codigo UNIQUE (CODIGO),
    CONSTRAINT CHK_Estados_Convocatoria_Codigo_Mayusculas CHECK (REGEXP_LIKE(CODIGO, '^[A-Z0-9_-]+$'))
);

-- Ejemplos de estados:
-- 1. Abierta
-- 2. Cerrada
-- 3. Impartiéndose
-- 4. Cancelada
-- 5. Finalizada

CREATE TABLE Convocatorias (
    ID             NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO         RAW(16)         DEFAULT SYS_GUID() NOT NULL,
    CURSO_ID       NUMBER          NOT NULL,
    FECHA_INICIO   DATE            NOT NULL,
    FECHA_FIN      DATE            NOT NULL,
    ESTADO_ID      NUMBER          NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Convocatorias PRIMARY         KEY (ID),
    CONSTRAINT UQ_Convocatorias_Codigo          UNIQUE (CODIGO),
    CONSTRAINT FK_Convocatorias_Curso FOREIGN   KEY (CURSO_ID)      REFERENCES Cursos(ID),
    CONSTRAINT FK_Convocatorias_Estado FOREIGN  KEY (ESTADO_ID)     REFERENCES Estados_Convocatoria(ID),
    CONSTRAINT CHK_Convocatorias_Fechas         CHECK (FECHA_FIN >= FECHA_INICIO)
) PCTFREE 0;

-- SELECT * FROM Convocatorias WHERE CURSO_ID = :curso_id;
-- Esto es fullscan. Si esta búsqueda se hace mucho, me interesa un índice sobre CURSO_ID. NO SE AHORA MISMO
-- Qué tipo de índice me interesaría para Curso_ID? B-TREE (normalito)
--     CREATE INDEX IX_Convocatorias_Curso_ID ON Convocatorias(CURSO_ID);
--     Usamos BTREE porque: Hay muchos valores distintos (no hay búsquedas de rangos)
-- SELECT * FROM Convocatorias WHERE ESTADO_ID = :estado_id;
-- Esto es fullscan. Si esta búsqueda se hace mucho, me interesa un índice sobre ESTADO_ID. NO SE AHORA MISMO
-- Qué tipo de índice me interesaría para ESTADO_ID? BITMAP (pocos valores distintos)
--     CREATE BITMAP INDEX IX_Convocatorias_Estado_ID ON Convocatorias(ESTADO_ID);
--     Los BITMAP los usamos cuando:
--             - Hay pocos valores distintos
--             - y no se hacen búsquedas de rangos
-- SELECT * FROM Convocatorias WHERE FECHA_INICIO >= :fecha1 AND FECHA_FIN <= :fecha2;
-- Esto es fullscan. Si esta búsqueda se hace mucho, me interesa un índice sobre (FECHA_INICIO, FECHA_FIN). NO SE AHORA MISMO
-- Qué tipo de índice me interesaría para (FECHA_INICIO, FECHA_FIN)? B-TREE (normalito)
--     CREATE INDEX IX_Convocatorias_Fechas ON Convocatorias(FECHA_INICIO, FECHA_FIN);
--     Los BTREE los usamos porque se hacen búsquedas de rangos (además porque hay muchos valores distintos)



-- SELECT RAWTOHEX(CODIGO) FROM Convocatorias;
-- Una fila de esta tabla ocupa en bytes: 
-- ID -> 6 bytes
-- CODIGO -> 16 bytes
-- CURSO_ID -> 6 bytes
-- FECHA_INICIO -> 7 bytes
-- FECHA_FIN -> 7 bytes
-- ESTADO_ID -> 6 bytes
-- TOTAL: 48 bytes + overhead de fila (unos 3-7 bytes más)
-- TOTAL APROXIMADO: 55 bytes por fila
-- En un bloque de 8kb, quitando info de cabecera y demás, podríamos meter unos 140 registros por bloque

-- Esta tabla es un x5 x10 de la tabla cursos. 
-- Cada curso lo impartiremos 5-10-20 veces.. quizás más?
-- Si fuera una tabla grande, que tendría sentido aquí? PARTICIONES. Más adelante ponemos un ejemplo de esto y comentamos acerca del particionado de tablas.


-- Más adelante iremos matriculando alumnos en las convocatorias
-- Tabla Matriculas (Alumno, Convocatoria, ...)
-- Alguna restricción que pensáis que vayamnos a aplicar en esta tabla: Matriculas?
-- - Máximo de alumnos matriculados. >> REGLA DE NEGOCIO !!!!!
-- - Que no haya matriculaciones simultáneas (misma persona en convocatorias con misma fecha). >> REGLA DE NEGOCIO !!!!!
-- - Convocatorias para una empresa concreta. >> REGLA DE NEGOCIO !!!!!
-- - No alumno 2 veces en la misma convocatoria <<< UNIQUE
-- - Que solo podamos matricular alumnos en convocatorias que no estén en estado "FINALIZADO" . >> REGLA DE NEGOCIO !!!!!
--   Por otra vía querría permitir la carga de datos saltándose esas restricción? SI --> REGLA DE NEGOCIO !!!!!
--   En una app de gestión, no debería ser posible matricular alumnos en convocatorias finalizadas
--   Pero en un proceso de carga masiva de datos históricos, podría ser necesario saltarse esa restricción
--   No es una restricción que aplique a nivel de base de datos, sino a nivel de aplicación
--   De hecho, podría tener una app pública, donde se apunta usuarios que solo pueden hacerlo si la convocatoria está abierta
--   Y otra app interna de gestión, donde los administradores pueden matricular alumnos siempre y cuando no esté finalizada
--   Para distintas apps puede ser que quiera aplicar distintas reglas de negocio

CREATE TABLE Alumnos (
    ID              NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    NOMBRE          VARCHAR2(50)    NOT NULL COLLATE SPANISH,
    APELLIDOS       VARCHAR2(150)   NOT NULL COLLATE SPANISH,
    DNI             VARCHAR2(9)     NOT NULL,
    EMAIL           VARCHAR2(100)   NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Alumnos PRIMARY            KEY (ID),
    CONSTRAINT UQ_Alumnos_DNI                UNIQUE (DNI),
    CONSTRAINT UQ_Alumnos_EMAIL              UNIQUE (EMAIL)
    -- Restricciones al DNI aplicadas mediante un TRIGGER (el mismo que para Profesores)
    -- Restricciones al EMAIL aplicadas mediante un TRIGGER (similar al del DNI, pero con regex para emails)
) PCTFREE 5;
-- Una fila ocupará aprox:
-- ID (6 bytes) + NOMBRE (50 bytes) + APELLIDOS (150 bytes) + DNI (9 bytes) + EMAIL (100 bytes) + overhead (10 bytes)
-- Total aprox: 325 bytes por fila
-- En un bloque de 8kb, quitando cabeceras y demás, podríamos meter unos 24 registros por bloque

-- Como mucho hará búsquedas del tipo LIKE DNI|EMAIL % que está cubiertas por los índices de las unique constraints
-- No tengo índices para búsquedas por nombre o apellidos
-- Podríamos crearlos si hiciera falta o incluso uno sobre columna virtual, similar a Profesores
-- Todo eso bajo demanda


CREATE OR REPLACE TRIGGER TRG_Alumnos_DNI_Validar_Normalizar
BEFORE INSERT OR UPDATE ON Alumnos
FOR EACH ROW
DECLARE
    dni_valido      BOOLEAN;
    dni_numero      NUMBER(8);
    dni_letra       CHAR(1);
BEGIN
    -- Si el DNI Es null, no hacemos nada, y que el propio NOT NULL de la tabla se encargue de rechazarlo
    IF :NEW.DNI IS NULL THEN
        RETURN;
    END IF;
    -- Validar el formato del DNI
    dni_utils.validar_dni(:NEW.DNI, dni_valido, dni_numero, dni_letra);
    IF NOT dni_valido THEN
        RAISE_APPLICATION_ERROR(-20001, 'DNI inválido: ' || :NEW.DNI); -- Este mensaje le saldrá al usuario si el DNI no es válido
    ELSE
        -- Si es válido, normalizar el valor del DNI
        :NEW.DNI := TO_CHAR(dni_numero) || dni_letra; -- Número sin ceros a la izquierda + letra en mayúsculas, sin puntos ni separadores
    END IF;
END;
/

-- Contraseña! Cómo la gestiono?
-- Primero, hoy en día... mejor esto se lo dejo a una herramienta experta en gestión de identidades y accesos (IAM).
-- Y a nivel de mi app, solo gestiono tokens de acceso temporales (JWT, OAuth2, OpenID Connect, etc)
-- Eso es lo que HAY QUE HACER

-- Que me pongo cabezón.. Por mis narices gestiono yo la contraseña.
-- Nunca guardo la contraseña encriptada! JAMAS. Si me ganan la máquina y la clave de encriptación, tienen todas las contraseñas.
-- Resultado: NUNCA GUARDO UNA CONTRASEÑA EN BBDD... ni en texto PLANO, ni ENCRIPTADA. NO SE HACE!
-- Lo que podría hacer es guardar un HASH de la contraseña. Una huella!
-- La letra del DNI? Una huella digital, un hash del número del DNI.
-- Algoritmo de huella:
-- Una función que:
-- - Dada una misma entrada siempre produce la misma salida
-- - Hay muy poca probabilidad de que 2 entradas distintas produzcan la misma salida (colisión). Buscamos funciones con % muy bajas de colisión
--   En el caso del DNI la probabilidad de colisión es de 1 entre 23 (solo hay 23 letras posibles) = 4.34%
--   El ministerio ha considerado que la probabilidad de colisión es suficientemente baja como para usar esa función para determinar si alguna persona ha cometido un error al escribir su DNI
-- - El resultado se considera un resumen del dato de entrada. Es decir, no es posible recuperar el dato original a partir de la huella

-- De hecho, un buen sistema de IAM guarda un hash, del hash, del hash (y así unas 1000 veces) de la contraseña.

CREATE TABLE Alumnos_Empresas (
    ALUMNO_ID      NUMBER      NOT NULL,
    EMPRESA_ID     NUMBER      NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Alumnos_Empresas PRIMARY KEY (ALUMNO_ID, EMPRESA_ID),
    CONSTRAINT FK_Alumnos_Empresas_Alumno FOREIGN KEY (ALUMNO_ID) REFERENCES Alumnos(ID),
    CONSTRAINT FK_Alumnos_Empresas_Empresa FOREIGN KEY (EMPRESA_ID) REFERENCES Empresas(ID)
);
-- Tengo cubiertas las búsquedas por alumno (para ver las empresas a las que pertenece un alumno)
-- Pero no las búsquedas por empresa (para ver los alumnos que pertenecen a una empresa)
-- Si esa búsqueda se hiciera mucho: 
-- CREATE INDEX IX_Alumnos_Empresas_Empresa ON Alumnos_Empresas(EMPRESA_ID, ALUMNO_ID);

-- Matriculas
CREATE TABLE Estados_Matricula (
    ID          NUMBER          GENERATED BY DEFAULT AS IDENTITY,
    CODIGO      VARCHAR2(20)    NOT NULL,
    NOMBRE      VARCHAR2(100)   NOT NULL,

 -- CONSTRAINS
    CONSTRAINT PK_Estados_Matricula PRIMARY KEY (ID),
    CONSTRAINT UQ_Estados_Matricula_Codigo UNIQUE (CODIGO),
    CONSTRAINT CHK_Estados_Matricula_Codigo_Mayusculas CHECK (REGEXP_LIKE(CODIGO, '^[A-Z0-9_-]+$'))
);

-- Alumno_ID, Empresa_ID, Convocatoria_ID, Estado_ID, Fecha_Matricula, Precio, Descuento, Precio_Final
CREATE TABLE Matriculas (
    ID               NUMBER      GENERATED BY DEFAULT AS IDENTITY,
    ALUMNO_ID        NUMBER      NOT NULL,
    EMPRESA_ID       NUMBER,
    CONVOCATORIA_ID  NUMBER      NOT NULL,
    ESTADO_ID        NUMBER      NOT NULL,
    FECHA_MATRICULA  DATE        NOT NULL,
    PRECIO           NUMBER(10,2) NOT NULL,
    DESCUENTO        NUMBER(5,2)  NOT NULL,
    PRECIO_FINAL     NUMBER(10,2) NOT NULL,

 -- CONSTRAINS
    -- Primary Key compuesta por los 3 campos
    CONSTRAINT PK_Matriculas PRIMARY KEY (ID), -- Ahora haremos algún comentario
    CONSTRAINT UNIQUE_Matriculas UNIQUE (ALUMNO_ID, EMPRESA_ID, CONVOCATORIA_ID), -- Ahora haremos algún comentario
    -- Foreign Keys
    -- Convocatoria
    CONSTRAINT FK_Matriculas_Convocatoria FOREIGN KEY (CONVOCATORIA_ID) REFERENCES Convocatorias(ID),
    -- Alumnos
    CONSTRAINT FK_Matriculas_Alumno FOREIGN KEY (ALUMNO_ID) REFERENCES Alumnos(ID),
    -- Empresas
    -- CONSTRAINT FK_Matriculas_Empresa FOREIGN KEY (EMPRESA_ID) REFERENCES Empresas(ID),
    -- Error: No puedo meter cualquier empresa. Solamente empresas para las que el alumno esté asociado/registrado en Alumnos_Empresas
    -- ESTA ES LA OPCIÓN BUENA:
    CONSTRAINT FK_Matriculas_Empresa FOREIGN KEY (ALUMNO_ID, EMPRESA_ID) 
        REFERENCES Alumnos_Empresas(ALUMNO_ID, EMPRESA_ID),
    -- El tratamiento que hace la BBDD cuando un campo FK es NULL es no aplicar la restricción
    -- Estado
    CONSTRAINT FK_Matriculas_Estado FOREIGN KEY (ESTADO_ID) REFERENCES Estados_Matricula(ID),
    -- CONTRAINS SOBRE LOS RANGOS DE LOS DATOS:
    CONSTRAINT CHK_Matriculas_Precio_Positive CHECK (PRECIO >= 0),
    CONSTRAINT CHK_Matriculas_Descuento_Range CHECK (DESCUENTO >= 0 AND DESCUENTO <= 100),
    CONSTRAINT CHK_Matriculas_Precio_Final_Positive CHECK (PRECIO_FINAL >= 0)
) PCTFREE 5;

-- Tamaño de fila
-- ID (6 bytes) + ALUMNO_ID (6 bytes) + EMPRESA_ID (6 bytes) + CONVOCATORIA_ID (6 bytes) + ESTADO_ID (6 bytes)
-- + FECHA_MATRICULA (7 bytes) + PRECIO (12 bytes) + DESCUENTO (7 bytes) + PRECIO_FINAL (12 bytes)
-- + overhead (10 bytes)
-- Total aprox: 72 bytes por fila
-- En un bloque de 8kb, quitando cabeceras y demás, podríamos meter unos 110 registros por bloque
-- Campos que pueden modificarse con frecuencia e impacto sobre el tamaño de fila?
--     ESTADO_ID        NUMBER      NOT NULL,
--     DESCUENTO        NUMBER(5,2)  NOT NULL,
--     PRECIO_FINAL     NUMBER(10,2) NOT NULL,
-- El cambio de tamaño es despreciable... no hay riesgo de que la fila crezca mucho y tenga que moverse a otro bloque
-- PCTFREE Muy bajo
-- Collates No aplican
-- Índices bajo demanda
--    EMPRESA_ID          BTREE: CREATE INDEX IX_Matriculas_Empresa_ID ON Matriculas(EMPRESA_ID);
--    ESTADO_ID           BITMAP: CREATE BITMAP INDEX IX_Matriculas_Estado_ID ON Matriculas(ESTADO_ID);
--    FECHA_MATRICULA     BTREE: CREATE INDEX IX_Matriculas_Fecha_Matricula ON Matriculas(FECHA_MATRICULA);

-- OTRO TEMA IMPORTANTE:
-- Esta es la tabla más grande de todas las que hemos creado hasta ahora
-- Puede ser objeto de particionado en el futuro


CREATE INDEX IX_Matriculas_Convocatoria_Alumno ON Matriculas(CONVOCATORIA_ID, ALUMNO_ID);

-- Necesito facilitar el acceso a las matrículas por convocatoria o por alumno
--- En el caso de alumno podría usar el índice de la UK (ALUMNO_ID, EMPRESA_ID, CONVOCATORIA_ID)
--- Pero en el caso de convocatoria no me vale ese índice, ya que el orden es distinto
--- Por eso creo este índice compuesto sobre (CONVOCATORIA_ID, ALUMNO_ID)

-- CONSTRAINT PK_Matriculas PRIMARY KEY (ALUMNO_ID, EMPRESA_ID, CONVOCATORIA_ID), -- Ahora haremos algún comentario
-- Por que he dicho que iba a hacer algunos comentarios aquí?
-- Si la empresa es Null, no hay problema, porque la PK sigue siendo única, incluyendo el NULL

-- Que estamos haciendo con esa línea? Cuál es su impacto real dentro de la BBDD?
-- - En automático Oracle va a generar un ÍNDICE único para esa PK
-- - Ese índice me interesa? Quiero decir... Entiendo que oracle cuando voy a dar una de alta una matrícula mira rápidito en ese índice 
-- - si ya existe esa matrícula para dar un "unique constraint violation"
-- - La pregunta es... se usará ese indice en mis búsquedas?
--   Por ejemplo: "Dame todos los alumnos que están matriculados en esta convocatoria"
--      SELECT * FROM Matriculas WHERE CONVOCATORIA_ID = 1234;
--   No se usaría por Oracle, ya que el orden del índice es (ALUMNO_ID, EMPRESA_ID, CONVOCATORIA_ID)
--   En esa query estoy entrando por CONVOCATORIA_ID, que es el tercer campo del índice. No vale para nada ese índice en esa query
--   Si hago esta query:
--      SELECT * FROM Matriculas WHERE ALUMNO_ID = 5678 
--   Sí se usaría el índice, ya que estoy entrando por el primer campo del índice
--   Eso lo tengo que tener en cuenta... e intentar adivinar el principal patrón de acceso a los datos que voy a tener pasa esa tabla
--   Siempre podré crear más índices a futuro... pero cuantos índices más cree, más espacio en disco voy a usar y más lentas serán las operaciones de INSERT/UPDATE/DELETE
--   Decisiones:
--    - Entraré principalmente por alumno? Dame todas las matrículas de un alumno
--    - Entraré principalmente por convocatoria? Dame todas las matrículas de una convocatoria
--    - Entraré principalmente por empresa? Dame todas las matrículas de una empresa
-- Es jugarmela!
-- Y posiblemente acabe creando varios índices.

-- Otra nota. Tenemos muchos foreign keys en esta tabla.
-- Genera Oracle índices para los foreign keys? NO
--   Caso que haya muchas consultas (JOINS) que usen esos foreign keys, me interesará crear índices para esos foreign keys


-- EVALUACIONES (Imagina que solo quiero la evaluación final... puede ser que se vayan metiendo notas parciales, pero al final solo quiero guardar la nota final)
-- MATRICULA_ID, FECHA_EVALUACION, NOTA, OBSERVACIONES
-- Pero.. solo quiero guardar el último valor

-- Como es la relación entre Matriculas y Evaluaciones?
-- 1 x 1 . Teníamos ya ejemplos de relaciones 1xn, de relaciones nxm... pero 1x1 no.
-- Aunque.. tiene esto sentido? Quiero decir...
-- Por qué no meter estos campos directamente en la tabla Matriculas? PUEDO METERLOS ALLI, ya que es 1x1
-- Por qué leches entonces no los meto allí y me quito de crear otra tabla... y sus relaciones y mierdecillas... si al final es 1x1?

-- Con qué frecuencia cambian los datos de una matricula en la tabla Matriculas? POCA...
-- Con qué frecuencia cambian los datos de evaluación? MÁS A MENUDO...
-- En general no me interesa mucho mezclar campos que cambian poco con campos que cambian más a menudo
-- Eso me hace un destrozo en las tablas. De este tema hablaremos también más despacio en el curso de ADMINISTRACIÓN DE BASES DE DATOS

-- Cuando modifico una fila, o cuando la borro, realmente El dato no se borra físicamente de disco.. solo se marca como borrado
-- En una modificación puede pasar que el campo observaciones pase de tener 10 caracteres a tener 100 caracteres.
-- Y ese espacio no esta reservado en la fila original, que se guardaba dentro de un bloque de datos(página)
-- En el mejor escenario, si hay espacio libre en el bloque de datos, se mete allí. Si no hay hueco ya en el bloque de datos, 
-- Y acabará no habiendo espacio en el bloque de datos, se tendrá que mover la fila a otro bloque de datos.
-- Pero eso de "mover la fila" es un eufemismo. Lo que realmente pasa es:
-- - Se marca la fila original como borrada (no se borra físicamente, solo se marca como borrada). Sigue allí ocupando espacio.
-- - Se crea una nueva fila en otro bloque de datos con el nuevo valor... y es necesario refrescar TODOS los índices donde esa fila estaba referenciada
--   para que apunten a la nueva ubicación de la fila
-- Esto hay que tenerlo en cuenta. Sobre todo cuando hay campos de tipo VARCHAR2, CLOB, BLOB, cuyos tamaños puedan variar mucho (como es el caso de nuestras evaluaciones: Observaciones)
-- me interesa esos campos llevarmelos a otra tabla, para evitar ese tipo de problemas en la tabla principal (Matriculas)
-- Esto mejora un huevo el rendimiento de las operaciones de UPDATE en la tabla Matriculas y nos libera de muchas complicaciones en el mantenimiento de la BBDD.
-- A las tablas, de vez en cuando hay que pegarles un repasito: OPTIMIZE TABLE Matriculas; 
-- O VACUUM en Postgres, o REORGANIZE en SQL Server, etc
-- Comprime la tabla, elimina filas marcadas como borradas, junta fragmentos, etc
-- Cuantos menos datos tenga, mejor! Con menos frecuencia tendré que hacer ese mantenimiento

CREATE TABLE Evaluaciones (
    MATRICULA_ID     NUMBER      NOT NULL,
    FECHA_EVALUACION DATE        NOT NULL,
    NOTA             NUMBER(5,2) NOT NULL,
    OBSERVACIONES    VARCHAR2(2000),

 -- CONSTRAINS
    CONSTRAINT PK_Evaluaciones PRIMARY KEY (MATRICULA_ID),
    CONSTRAINT FK_Evaluaciones_Matricula FOREIGN KEY (MATRICULA_ID) REFERENCES Matriculas(ID),
    CONSTRAINT CHK_Evaluaciones_Nota_Range CHECK (NOTA >= 0 AND NOTA <= 10)
);

-- Esta tabla si crece mucho (en paralelo a la tabla Matriculas) puede tener sentido particionarla

-- Hemos separado datos en 2 tablas: Matriculas y Evaluaciones ya que:
-- Los datos de Evaluaciones cambian más a menudo que los datos de Matriculas
-- Al tener los datos de Evaluaciones en otra tabla, 
-- evitamos que las filas de Matriculas tengan que moverse a otros bloques de datos
-- Puede pasar que eso ocurra en la tabla de evaluaciones, y es una tabla que deberá tener
-- un mantenimiento periódico

-- Podría interesarme facilitar el acceso a todos los datos juntos.
-- Que cuando alguien quiera consultar los datos vengan juntos los de ambas tablas: VIEW

-- Una VIEW es solo un alias que defino para una consulta SQL
CREATE OR REPLACE VIEW VW_Datos_Matriculacion AS
SELECT 
    m.ID AS MATRICULA_ID,
    m.ALUMNO_ID,
    m.EMPRESA_ID,
    m.CONVOCATORIA_ID,
    m.ESTADO_ID,
    m.FECHA_MATRICULA,
    m.PRECIO,
    m.DESCUENTO,
    m.PRECIO_FINAL,
    e.FECHA_EVALUACION,
    e.NOTA,
    e.OBSERVACIONES
FROM Matriculas m
LEFT JOIN Evaluaciones e ON m.ID = e.MATRICULA_ID;
-- Esta VIEW me permite acceder a los datos de ambas tablas como si fuera una sola tabla

--Imaginad este escenario
-- Quiero un cuadro de mando con estadísticas de las matrículas en mi app de gestión:

-- Quiero para cada convocatoria (CODIGO DE CURSO + FECHA INICIO + FECHA FIN):
-- - Número de matrículas
-- - Suma Precio final de las matrículas
-- - Número de aprobados
-- - De aquellas convocatorias que hayan acabado la última semana

SELECT 
    c.CODIGO AS CURSO_CODIGO,
    c.FECHA_INICIO,
    c.FECHA_FIN,
    COUNT(m.ID) AS NUMERO_MATRICULAS,
    SUM(m.PRECIO_FINAL) AS SUMA_PRECIO_FINAL,
    SUM(CASE WHEN e.NOTA >= 5 THEN 1 ELSE 0 END) AS NUMERO_APROBADOS
FROM Convocatorias c
LEFT JOIN Matriculas m ON c.ID = m.CONVOCATORIA_ID
LEFT JOIN Evaluaciones e ON m.ID = e.MATRICULA_ID
WHERE c.FECHA_FIN >= SYSDATE - 7 AND c.FECHA_FIN < SYSDATE
GROUP BY c.CODIGO, c.FECHA_INICIO, c.FECHA_FIN
ORDER BY c.FECHA_FIN DESC;

-- Esa query tiene pinta de ser pesada o no? PESADO... 
-- En este tipo de queries que usamos en cuandros de mando, me puede pasar que si sea necesario hacer FULL SCAN de las tablas
-- Y el particionado aquí podría ayudar: PRUNING DE PARTICIONES

-- Podría meter esta query en una VIEW
-- Pero... cada vez que la gente entre en la app, lo primero que va a ver es ese cuadro de mando. Así he diseñado la app.
-- Y cada vez que eso ocurra, se va a ejecutar esa query. Eso es un desmadre.

-- Este es el caso de uso de los MATERIALIZED VIEWS de Oracle. Esto es una funcionalidad que no tienen todas las BBDD
-- Una MATERIALIZED VIEW es un híbrido entre una tabla y una view
-- Es una tabla que se crea a partir del resultado de una query

-- Mientras que las views son solo un alias para una query SQL... y cuando alguien accede a la view, se ejecuta la query
-- Las materialized views son tablas físicas que se crean a partir del resultado de una query SQL

-- La gracia además es que Oracle se encarga de mantener actualizada esa tabla materialized view
-- Y hay distintas formas de hacerlo:
-- - Cada cierto tiempo (cada 5 minutos, cada hora, cada día, etc) <-- ESTE ES GUAY y el QUE MÁS SE USA
-- - Cada vez que se hacen cambios en las tablas base (insert, update, delete) <<< Este es harto peligroso...Cada vez que hay un cambio en las tablas base, hay que actualizar la materialized view = RUINA !
-- - Manualmente (cuando yo quiera) <-- Bueno...

-- quiero cada hora que se refresque

CREATE MATERIALIZED VIEW MV_Convocatorias_Estadisticas
BUILD IMMEDIATE
REFRESH FAST
START WITH SYSDATE
NEXT SYSDATE + 1/24 -- Cada hora
AS
SELECT 
    c.CODIGO AS CURSO_CODIGO,
    c.FECHA_INICIO,
    c.FECHA_FIN,
    COUNT(m.ID) AS NUMERO_MATRICULAS,
    SUM(m.PRECIO_FINAL) AS SUMA_PRECIO_FINAL,
    SUM(CASE WHEN e.NOTA >= 5 THEN 1 ELSE 0 END) AS NUMERO_APROBADOS
FROM Convocatorias c
LEFT JOIN Matriculas m ON c.ID = m.CONVOCATORIA_ID
LEFT JOIN Evaluaciones e ON m.ID = e.MATRICULA_ID
WHERE c.FECHA_FIN >= SYSDATE - 7 AND c.FECHA_FIN < SYSDATE
GROUP BY c.CODIGO, c.FECHA_INICIO, c.FECHA_FIN
ORDER BY c.FECHA_FIN DESC;

-- Cuando alguien acceda a la materialized view, no se ejecutará la query
-- Sino que se accederá directamente a la tabla física que Oracle ha creado para esa materialized view
-- Y esa tabla física se actualizará cada hora con los datos más recientes

-- Para un cuadro de mando de este tipo, es una solución perfecta... posiblemente ver los datos con un desfase de 1 hora no es un problema
-- Sobre todo teniendo en cuenta que ese "1 hora" puede ser configurado a lo que yo quiera (10 minutos, 30 minutos, 2 horas, etc)
-- En algunos casos puede ser incluso 1 día o 1 semana